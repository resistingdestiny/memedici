// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
import {Proof} from "vlayer-0.1.0/Proof.sol";
import {Prover} from "vlayer-0.1.0/Prover.sol";
import {Web, WebProof, WebProofLib, WebLib} from "vlayer-0.1.0/WebProof.sol";

/**
 * @title ContentAuthenticityProver
 * @dev Proves that content was generated by legitimate AI APIs (Novita, OpenAI)
 * Prevents users from claiming uploaded content as AI-generated
 */
contract ContentAuthenticityProver is Prover {
    using Strings for string;
    using WebProofLib for WebProof;
    using WebLib for Web;

    // Supported AI service endpoints
    string constant NOVITA_API_URL = "https://api.novita.ai/v3/async/txt2img";
    string constant OPENAI_API_URL = "https://api.openai.com/v1/images/generations";

    struct ContentAuthenticityProof {
        string apiEndpoint;           // Which AI service was used
        string prompt;                // User's original prompt
        string modelName;             // AI model used
        uint256 timestamp;            // When generation occurred
        bytes32 responseHash;         // Hash of API response
        uint256 width;                // Image dimensions
        uint256 height;
        string contentId;             // Unique content identifier
        bool verified;                // Proof verification status
    }

    /**
     * @dev Prove Novita AI image generation authenticity
     * @param webProof The notarized HTTP request/response to Novita API
     * @param expectedPrompt The prompt user claims to have used
     * @param contentId Unique identifier for the generated content
     */
    function proveNovitaGeneration(
        WebProof calldata webProof,
        string calldata expectedPrompt,
        string calldata contentId
    ) public view returns (Proof memory, ContentAuthenticityProof memory) {
        
        // Verify the web proof came from Novita API
        Web memory web = webProof.verify(NOVITA_API_URL);
        
        // Extract and verify request data
        string memory requestBody = web.jsonGetString("request_body");
        string memory actualPrompt = web.jsonGetString("prompt");
        string memory modelName = web.jsonGetString("model_name");
        string memory width = web.jsonGetString("width");
        string memory height = web.jsonGetString("height");
        
        // Verify prompt matches what user claims
        require(
            keccak256(abi.encodePacked(actualPrompt)) == keccak256(abi.encodePacked(expectedPrompt)),
            "Prompt mismatch: user claimed different prompt"
        );
        
        // Extract response data to prove generation occurred
        string memory responseStatus = web.jsonGetString("status");
        require(
            keccak256(abi.encodePacked(responseStatus)) == keccak256(abi.encodePacked("200")),
            "API call failed - no content generated"
        );
        
        // Get image data from response
        string memory imageData = web.jsonGetString("images_encoded");
        require(bytes(imageData).length > 0, "No image data in response");
        
        // Create response hash for integrity
        bytes32 responseHash = keccak256(abi.encodePacked(imageData));
        
        // Get timestamp from HTTP headers
        string memory timestamp = web.getHeader("date");
        uint256 generationTime = block.timestamp; // Simplified for POC
        
        ContentAuthenticityProof memory authProof = ContentAuthenticityProof({
            apiEndpoint: NOVITA_API_URL,
            prompt: actualPrompt,
            modelName: modelName,
            timestamp: generationTime,
            responseHash: responseHash,
            width: _stringToUint(width),
            height: _stringToUint(height),
            contentId: contentId,
            verified: true
        });
        
        return (proof(), authProof);
    }

    /**
     * @dev Prove OpenAI image generation authenticity  
     * @param webProof The notarized HTTP request/response to OpenAI API
     * @param expectedPrompt The prompt user claims to have used
     * @param contentId Unique identifier for the generated content
     */
    function proveOpenAIGeneration(
        WebProof calldata webProof,
        string calldata expectedPrompt,
        string calldata contentId
    ) public view returns (Proof memory, ContentAuthenticityProof memory) {
        
        // Verify the web proof came from OpenAI API
        Web memory web = webProof.verify(OPENAI_API_URL);
        
        // Extract request data
        string memory actualPrompt = web.jsonGetString("prompt");
        string memory model = web.jsonGetString("model");
        string memory size = web.jsonGetString("size");
        string memory quality = web.jsonGetString("quality");
        
        // Verify prompt authenticity
        require(
            keccak256(abi.encodePacked(actualPrompt)) == keccak256(abi.encodePacked(expectedPrompt)),
            "Prompt mismatch: user claimed different prompt"
        );
        
        // Verify successful generation
        string memory responseStatus = web.jsonGetString("status");
        require(
            keccak256(abi.encodePacked(responseStatus)) == keccak256(abi.encodePacked("200")),
            "API call failed - no content generated"
        );
        
        // Extract image data
        string memory imageUrl = web.jsonGetString("data.0.url");
        string memory imageB64 = web.jsonGetString("data.0.b64_json");
        
        // At least one image format should exist
        require(
            bytes(imageUrl).length > 0 || bytes(imageB64).length > 0,
            "No image data in response"
        );
        
        // Create response hash
        bytes32 responseHash = keccak256(abi.encodePacked(imageUrl, imageB64));
        
        // Parse dimensions from size (e.g., "1024x1024")
        (uint256 width, uint256 height) = _parseSize(size);
        
        ContentAuthenticityProof memory authProof = ContentAuthenticityProof({
            apiEndpoint: OPENAI_API_URL,
            prompt: actualPrompt,
            modelName: model,
            timestamp: block.timestamp,
            responseHash: responseHash,
            width: width,
            height: height,
            contentId: contentId,
            verified: true
        });
        
        return (proof(), authProof);
    }

    /**
     * @dev Prove generic API-based content generation
     * @param webProof The notarized HTTP request/response
     * @param apiEndpoint Expected API endpoint
     * @param expectedPrompt The prompt user claims to have used
     * @param contentId Unique identifier for the generated content
     */
    function proveGenericAPIGeneration(
        WebProof calldata webProof,
        string calldata apiEndpoint,
        string calldata expectedPrompt,
        string calldata contentId
    ) public view returns (Proof memory, ContentAuthenticityProof memory) {
        
        // Verify the web proof came from expected API
        Web memory web = webProof.verify(apiEndpoint);
        
        // Basic verification that this was a successful API call
        string memory responseStatus = web.jsonGetString("status");
        require(
            keccak256(abi.encodePacked(responseStatus)) == keccak256(abi.encodePacked("200")),
            "API call failed"
        );
        
        // Extract any available response data
        string memory responseBody = web.jsonGetString("response_body");
        bytes32 responseHash = keccak256(abi.encodePacked(responseBody));
        
        ContentAuthenticityProof memory authProof = ContentAuthenticityProof({
            apiEndpoint: apiEndpoint,
            prompt: expectedPrompt,
            modelName: "unknown",
            timestamp: block.timestamp,
            responseHash: responseHash,
            width: 0,
            height: 0,
            contentId: contentId,
            verified: true
        });
        
        return (proof(), authProof);
    }

    // Helper functions
    function _stringToUint(string memory s) internal pure returns (uint256) {
        bytes memory b = bytes(s);
        uint256 result = 0;
        for (uint256 i = 0; i < b.length; i++) {
            uint256 c = uint256(uint8(b[i]));
            if (c >= 48 && c <= 57) {
                result = result * 10 + (c - 48);
            }
        }
        return result;
    }
    
    function _parseSize(string memory size) internal pure returns (uint256, uint256) {
        // Parse "1024x1024" format
        bytes memory b = bytes(size);
        uint256 x_pos = 0;
        
        // Find 'x' position
        for (uint256 i = 0; i < b.length; i++) {
            if (b[i] == 'x') {
                x_pos = i;
                break;
            }
        }
        
        if (x_pos == 0) return (512, 512); // Default fallback
        
        // Extract width and height (simplified parsing)
        return (1024, 1024); // Simplified for POC
    }
} 